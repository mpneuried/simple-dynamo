// Generated by CoffeeScript 1.3.3
(function() {
  var Attributes, Helper, exports, utils, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require("underscore");

  utils = require("./utils");

  Helper = {
    val2dyn: function(value) {
      switch (typeof value) {
        case "number":
          return {
            N: String(value)
          };
        case "string":
          return {
            S: value
          };
      }
      if (value) {
        switch (typeof value[0]) {
          case "number":
            return {
              NN: value.map(String)
            };
          case "string":
            return {
              SS: value
            };
        }
      }
      throw new Error("Invalid key value type.");
    },
    dyn2val: function(data) {
      var name, value;
      name = Object.keys(data)[0];
      value = data[name];
      switch (name) {
        case "S":
        case "SS":
          return value;
        case "N":
          return Number(value);
        case "NS":
          return value.map(Number);
        default:
          throw new Error("Invalid data type: " + name);
      }
    },
    obj2dyn: function(attrs) {
      var obj;
      obj = {};
      Object.keys(attrs).forEach(function(key) {
        return obj[key] = Helper.val2dyn(attrs[key]);
      });
      return obj;
    },
    dyn2obj: function(data) {
      var obj;
      obj = {};
      Object.keys(data).forEach(function(key) {
        return obj[key] = Helper.dyn2val(data[key]);
      });
      return obj;
    }
  };

  Attributes = (function() {

    function Attributes(raw, table) {
      this.raw = raw;
      this.table = table;
      this._fixPredicateValue = __bind(this._fixPredicateValue, this);

      this._fixPredicate = __bind(this._fixPredicate, this);

      this.fixPredicates = __bind(this.fixPredicates, this);

      this.getQuery = __bind(this.getQuery, this);

      this.updateAttrsFn = __bind(this.updateAttrsFn, this);

      this.validateAttributes = __bind(this.validateAttributes, this);

      this.get = __bind(this.get, this);

      this.prepare = __bind(this.prepare, this);

      this.prepare();
      return;
    }

    Attributes.prototype.prepare = function() {
      var _attr, _hKey, _i, _len, _outE, _rKey, _ref;
      this.attrs || (this.attrs = {});
      this._required_attrs = [];
      _hKey = this.table.hashKey;
      _rKey = this.table.rangeKey;
      _ref = this.raw;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _attr = _ref[_i];
        if (_attr.required) {
          this._required_attrs.push(_attr.key);
        }
        _outE = _.clone(_attr);
        if (_outE.key === _hKey) {
          _outE.isHash = true;
        }
        if (_outE.key === _rKey) {
          _outE.isRange = true;
        }
        this.attrs[_outE.key] = _outE;
      }
      if (!this.attrs[_hKey]) {
        this.attrs[_hKey] = {
          key: _hKey,
          isHash: true,
          type: this.table.hashKeyType,
          required: true
        };
      }
      if (this.table.hasRange && !this.attrs[_rKey]) {
        this.attrs[_rKey] = {
          key: _rKey,
          isRange: true,
          type: this.table.rangeKeyType,
          required: true
        };
      }
    };

    Attributes.prototype.get = function(key) {
      return this.attrs[key] || null;
    };

    Attributes.prototype.validateAttributes = function(isCreate, attrs, cb) {
      var error, key, val, _attr;
      if (!utils.params(attrs, this._required_attrs)) {
        error = new Error;
        error.name = "validation-error";
        error.message = "Missing key. Please make sure to add all required keys ( " + this._required_attrs + " )";
        this.table._error(cb, error);
      } else {
        for (key in attrs) {
          val = attrs[key];
          _attr = this.get(key);
          if (_attr) {
            switch (_attr.type) {
              case "string":
                if (!_.isString(val)) {
                  error = new Error;
                  error.name = "validation-error";
                  error.message = "Wrong type of `" + key + "`. Please pass this key as a `String`";
                  this.table._error(cb, error);
                  return;
                }
                break;
              case "number":
                if (!_.isNumber(val)) {
                  error = new Error;
                  error.name = "validation-error";
                  error.message = "Wrong type of `" + key + "`. Please pass this key as a `Number`";
                  this.table._error(cb, error);
                  return;
                }
                break;
              case "array":
                if (isCreate) {
                  if (!_.isArray(val)) {
                    error = new Error;
                    error.name = "validation-error";
                    error.message = "Wrong type of `" + key + "`. Please pass this key as an `Array`";
                    this.table._error(cb, error);
                    return;
                  }
                } else {
                  if (!((val["$add"] != null) || (val["$rem"] != null) || (val["$reset"] != null)) && !_.isArray(val)) {
                    error = new Error;
                    error.name = "validation-error";
                    error.message = "Wrong type of `" + key + "`. Please pass this key as an `Array` or an Object of actions";
                    this.table._error(cb, error);
                    return;
                  }
                }
            }
          }
        }
        cb(null, attrs);
      }
    };

    Attributes.prototype.updateAttrsFn = function(_new, options) {
      var self;
      if (options == null) {
        options = {};
      }
      self = this;
      return function() {
        var val, _attr, _k, _tbl, _v, _vA;
        _tbl = self.table;
        for (_k in _new) {
          _v = _new[_k];
          if (!(_k !== _tbl.hashKey)) {
            continue;
          }
          _attr = self.get(_k);
          if (((_attr != null ? _attr.type : void 0) === "array" || (!_attr && ((_new[_k]["$add"] != null) || (_new[_k]["$rem"] != null) || (_new[_k]["$reset"] != null)))) && !_.isArray(_new[_k])) {
            val = _new[_k];
            if (val["$add"] != null) {
              _vA = (_.isArray(val["$add"]) ? val["$add"] : [val["$add"]]);
              this.add(_k, _vA);
            }
            if (val["$rem"] != null) {
              _vA = (_.isArray(val["$rem"]) ? val["$rem"] : [val["$rem"]]);
              this.remove(_k, _vA);
            }
            if (val["$reset"] != null) {
              _vA = (_.isArray(val["$reset"]) ? val["$reset"] : [val["$reset"]]);
              this.put(_k, _vA);
            }
          } else {
            if (_v === null) {
              this.remove(_k);
            } else {
              this.put(_k, _v);
            }
          }
        }
      };
    };

    Attributes.prototype.getQuery = function(table, query, startAt, options) {
      var isScan, _q, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      _ref = this.fixPredicates(query), _q = _ref[0], isScan = _ref[1];
      if (isScan) {
        if (this.table.mng.options.scanWarning) {
          console.warn("WARNING! Dynamo-Scan on `" + table.TableName + "`. Query:", _q);
        }
        _q = table.scan(_q);
      } else {
        _q = table.query(_q);
        if (!(options != null ? options.forward : void 0)) {
          _q.reverse();
        }
      }
      if (startAt != null) {
        _q.startAt(startAt);
      }
      if ((options != null ? options.limit : void 0) != null) {
        _q.limit(options.limit);
      }
      if (options != null ? (_ref1 = options.fields) != null ? _ref1.length : void 0 : void 0) {
        _q.get(options != null ? options.fields : void 0);
      }
      return [_q, isScan];
    };

    Attributes.prototype.fixPredicates = function(predicates) {
      var isScan, key, predicate, _attr, _fixed, _predCount;
      if (predicates == null) {
        predicates = {};
      }
      _fixed = {};
      isScan = !this.table.hasRange;
      _predCount = Object.keys(predicates).length;
      if (_predCount) {
        for (key in predicates) {
          predicate = predicates[key];
          _attr = this.get(key);
          if (_attr) {
            if (!_attr.isHash && !_attr.isRange) {
              isScan = true;
            }
            _fixed[key] = this._fixPredicate(predicate, _attr);
          }
        }
        if (!isScan && !utils.params(_fixed, [this.table.hashKey, this.table.rangeKey])) {
          isScan = true;
        }
      } else {
        isScan = true;
      }
      return [_fixed, isScan];
    };

    Attributes.prototype._fixPredicate = function(predicate, _attr) {
      var val, _a, _arrayAcceptOps, _i, _len, _op, _ops, _ref, _v;
      _ops = Object.keys(predicate);
      _arrayAcceptOps = ["<=", ">=", "in"];
      if (_ops.length === 1) {
        _op = _ops[0];
        if (_.isArray(predicate[_op]) && __indexOf.call(_arrayAcceptOps, _op) >= 0) {
          _a = [];
          _ref = predicate[_op];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            val = _ref[_i];
            _v = this._fixPredicateValue(val, _attr.type);
            if (_v) {
              _a.push(_v);
            }
          }
          predicate[_op] = _a;
        } else if (!_.isArray(predicate[_op])) {
          _v = this._fixPredicateValue(predicate[_op], _attr.type);
          if (_v) {
            predicate[_op] = _v;
          }
        } else {
          throw new Error("Malformed query. Arrays only allowed for `" + _arrayAcceptOps);
        }
      } else {
        throw new Error("Malformed query. Only exact one query operator will be accepted per key");
      }
      return predicate;
    };

    Attributes.prototype._fixPredicateValue = function(value, type) {
      var _vt;
      if (type == null) {
        type = "string";
      }
      _vt = typeof value;
      switch (type) {
        case "string":
          if (_vt !== "string" && _vt !== "undefined") {
            return value.toString();
          } else {
            return value;
          }
          break;
        case "number":
          if (_vt !== "number" && _vt !== "undefined") {
            return parseFloat(value, 10);
          } else {
            return value;
          }
          break;
        case "boolean":
          if (_vt !== "boolean" && _vt !== "undefined") {
            return Boolean(value);
          } else {
            return value;
          }
      }
    };

    return Attributes;

  })();

  exports = module.exports = Attributes;

  exports.helper = Helper;

}).call(this);
