{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"simple-dynamo","google":"UA-32491479-1","body":"simple-dynamo\r\n===========\r\nis a abstraction layer to Jed Schmidt's [dynamo](https://github.com/jed/dynamo) Node.js driver.\r\n\r\n[![Build Status](https://secure.travis-ci.org/mpneuried/simple-dynamo.png?branch=master)](http://travis-ci.org/mpneuried/simple-dynamo)\r\n\r\nIt provides a absolute simple JSON-CRUD Interface without any knowledge of Dynamos specialties.\r\n\r\nA special feature is the *combineTableTo* options for tables. It adds the ability to combine multiple models into one Dymamo-table, but use them separately in your application. So you have to pay only one throughput capacity.\r\n\r\n*Written in coffee-script*\r\n\r\n**INFO: all examples are written in coffee-script**\r\n\r\n# Install\r\n\r\n```\r\n  npm install simple-dynamo\r\n```\r\n\r\n# Connection and Table\r\n\r\n## Initialize\r\n\r\nfirst you have to define the connection and table attributes and get an instance of the simple-dynamo interface.\r\n\r\n`new SimpleDynamo( connectionSettings, tables )`\r\n\r\n###connection Settings\r\n\r\n- **accessKeyId** : Your AWS access key id\r\n- **secretAccessKey** : Your AWS secret access key\r\n- **region** : The region your Dynamo-Tables will be placed \r\n\r\n###table Definition\r\n\r\nAn Object of Tables.  \r\nThe key you are using will be the key to get the table object.\r\n\r\nEvery object can have the following keys:\r\n\r\n- **name** : *( `String` required )*  \r\nTablename for AWS\r\n- **hashKey** : *( `String` required )*  \r\nThe hash key name of your ids/hashes\r\n- **hashKeyType** : *( `String` optional: default = `S` )*  \r\nThe type of the `hashKey`. Possible values are: `S` = String and `N` = Numeric\r\n- **rangeKey**: *( String optional )*  \r\nThe range key name of your range attribute. If not defined the table will be generated without the range methods\r\n- **rangeKeyType**: *( `String` optional: default = `N` )*  \r\nThe type of the `rangeKey`. Possible values are: `S` = String and `N` = Numeric\r\n- **fnCreateHash**: *( `Function` optional: default = `new UUID` )*  \r\nMethod to generate a custom hash key.  \r\n- **defaultfields**: *( `Array` optional )*  \r\nList of fields to return as default. If nothing is defined all fields will be received. You always can overwrite this using `options.fields`.  \r\n- **combineTableTo**: *( `String` optional )*\r\nOption to combine multiple models into one dynamo-table. Makes sense if you want to pay only one table. Combinations are not allowed for tables of different types ( Hash-table and HashRange-table ) and you have to use the same hashKey and rangeKey. The module will handle all interactions with the models transparent, so you only have to define this option.  \r\n*Note:* If you use this feature and predefine the id/hash you have to add the `name` of the table in front of every id/hash.\r\n- **overwriteExistingHash**: *( `Boolean` optional: default = false )*  \r\nOverwrite a item on `create` of an existing hash. \r\n- **consistent**: *( `Boolean` optional: default = false )*  \r\nDo consistend reads on `table.get()` and `table.find()` as default   \r\n**Method Arguments**  \r\n  - **attributes**: The given attributes on create  \r\n  - **cb**: Callback method to pass the custom generates id/hash. `cb( \"my-special-hash\" )`\r\n- **fnCreateRange**: *( `Function` optional: default = `current Timestamp` )*  \r\nMethod to generate a custom range key.  \r\n**Method Arguments**  \r\n  - **attributes**: The given attributes on create  \r\n  - **cb**: Callback method to pass the custom generates id/hash. `cb( \"my-special-range\" )`\r\n- **attributes**: *( `Array of Objects` required )*  \r\nAn array of attribute Objects. Which will be validated  \r\n**Attributes keys**\r\n  - **key**: *( `String` required )*  \r\n  Column/Attribute name/key\r\n  - **type**: *( `String` required )*  \r\n  Datatype. possible values are `string` = String, `number` = Numeric and `array` = Array/Set of **Strings**\r\n  - **required**: *( `Boolean` optional: default = `false` )*  \r\n  Validate the attribute to be required. *( Not implemented yet ! )*\r\n   \r\n  \r\n**Example**\r\n\r\n```coffee\r\n# import module\r\nSimpleDynamo = require \"simple-dynamo\"\r\n\r\n# define connection settings\r\nconnectionSettings =\r\n\taccessKeyId: \"-\"\r\n\tsecretAccessKey: \"-\"\r\n\tregion: \"eu-west-1\"\r\n\t\r\n# define tables\r\ntables = \r\n\t\"Users\":\r\n\t\tname: \"users\"\r\n\t\thashKey: \"id\"\r\n\r\n\t\tattributes: [\r\n\t\t\t{ key: \"name\", type: \"string\", required: true }\r\n\t\t\t{ key: \"email\", type: \"string\" }\r\n\t\t]\r\n\t\t\r\n\t\"Todos\":\r\n\t\tname: \"todos\"\r\n\t\thashKey: \"id\"\r\n\t\trangeKey: \"_t\"\r\n\t\trangeKeyType: \"N\"\r\n\t\t\r\n\t\tfnCreateHash: ( attributes, cb )=>\r\n\t\t\tcb( attributes.user_id )\r\n\t\t\treturn\r\n\t\t\r\n\t\tattributes: [\r\n\t\t\t{ key: \"title\", type: \"string\", required: true }\r\n\t\t\t{ key: \"done\", type: \"number\" }\r\n\t\t]\r\n\t\r\n\t# example for a combined table usage\r\n\t\"Combined1\":\r\n\t\tname: \"c1\"\r\n\t\thashKey:  \"id\"\r\n\t\tcombineTableTo: \"combined_hash\"\r\n\r\n\t\tattributes: [\r\n\t\t\t{ key: \"title\", type: \"string\", required: true }\r\n\t\t]\r\n\t\r\n\t\"Combined2\":\r\n\t\tname: \"c2\"\r\n\t\thashKey:  \"id\"\r\n\t\tcombineTableTo: \"combined_hash\"\r\n\r\n\t\tattributes: [\r\n\t\t\t{ key: \"title\", type: \"string\", required: true }\r\n\t\t]\r\n\r\n# create instance\r\nsdManager = new SimpleDynamo( connectionSettings, tables )\r\n\r\n# connect\r\nsdManager.connect ( err )->\r\n\tconsole.log( \"simple-dynamo ready to use\" )\r\n```\r\n\r\n## First connect to AWS\r\n\r\nThe module has to know about the existing AWS tables so you have to read them first.  \r\n**If you do not run `.connect()` the module will throw an error everytime** \r\n\r\n**`Manager.connect( fnCallback )` Arguments** : \r\n\r\n- **fnCallback**: *( `Function` required )*  \r\nCallback method. Single arguments on return is the error object. On success the error is `null`\r\n \r\n**Example**\r\n\r\n```coffee\r\nsdManager.connect ( err )->\r\n\tif err\r\n\t\tconsole.error( \"connect ERROR\", err )\r\n\telse\r\n\t\tconsole.log( \"simple-dynamo ready to use\" )\r\n```\r\n\r\n## Create all tables\r\n\r\nto create all missing tables just call `.createAll()`.\r\n\r\nThis is not necessary if you know the tables has been created in the past.\r\n\r\n**Note! The generating of tables could take a few Minutes**\r\n\r\n**`Manager.generateAll( fnCallback )` Arguments** : \r\n\r\n- **fnCallback**: *( `Function` required )*  \r\nCallback method. Single arguments on return is the error object. On success the error is `null`\r\n\r\n**Example**\r\n\r\n```coffee\r\nsdManager.generateAll ( err )->\r\n\tif err\r\n\t\tconsole.error( \"connect ERROR\", err )\r\n\telse\r\n\t\tconsole.log( \"simple-dynamo ready to use\" )\r\n```\r\n\r\n## Get a table instance\r\n\r\nTo interact with a table you have to retrieve the table object. It's defined in the table-definitions\r\n\r\n**`Manager.get( 'tableName' )` Arguments** : \r\n\r\n- **tableName**: *( `String` required )*  \r\nMethod to retrieve the instance of a table object.\r\n\r\n**Example**\r\n\r\n```coffee\r\ntblTodos = sdManager.get( 'Todos' )\r\n```\r\n\r\n## Destroy a table\r\n\r\ndestroy table at AWS. This removes the table from AWS will all the data\r\n\r\n**`Table.destroy( fnCallback )` Arguments** : \r\n\r\n- **fnCallback**: *( `Function` required )*  \r\nCallback method.  \r\n**Method Arguments**  \r\n  - **err**: Usually `null`. On an error a object with `error` and `msg`\r\n\r\n**Example**\r\n\r\n```coffee\r\ntblTodos.del ( err )->\r\n\tif err\r\n\t\tconsole.error( \"destroy ERROR\", err )\r\n\telse\r\n\t\tconsole.log( \"table destroyed\" )\r\n```\r\n\r\n# Item handling \r\n\r\n## Write a new item (INSERT)\r\n\r\nCreate a new item in a select table. You can also add some attributes not defined in the table-definition, which will be saved, too.\r\n\r\n**`Table.set( data, options, fnCallback )` Arguments** : \r\n\r\n- **data**: *( `Object` required )*  \r\nThe data to save. You can define the hash and/or range key. If not the module will generate a hash/range automatically.  \r\n*Note:* If the used table uses the combined feature and you define the hash-key it's necessary to add the `name` out of the table-config in front of every hash.\r\n- **options**: *( `Object` optional )*  \r\n  - **fields**: *( `Array` )* An array of fields to receive\r\n  - **overwriteExistingHash**: *( `Boolean` optional: default = [tableConfig.overwriteExistingHash] )*  Overwrite a item it already exists. \r\n- **fnCallback**: *( `Function` required )*  \r\nCallback method.  \r\n**Method Arguments**  \r\n  - **err**: Usually `null`. On an error a object with `error` and `msg`\r\n  - **item**: the save item as simple object\r\n\r\n**Example**\r\n\r\n```coffee\r\ndata = \r\n\ttitle: \"My First Todo\"\r\n\tdone: 0\r\n\taditionalData: \"Foo bar\"\r\n\t\r\ntblTodos.set data, ( err, todo )->\r\n\tif err\r\n\t\tconsole.error( \"insert ERROR\", err )\r\n\telse\r\n\t\tconsole.log( todo )\r\n```\r\n\r\n## Get a item (GET)\r\n\r\nGet an existing element by id/hash\r\n\r\n**`Table.get( id, fnCallback )` Arguments** : \r\n\r\n- **id**: *( `String|Number|Array` required )*  \r\nThe id of an element. If the used table is a range table you have to use an array `[hash,range]` as combined id. Otherwise you will get an error. \r\n- **options**: *( `Object` optional )*  \r\n  - **fields**: *( `Array` )* An array of fields to receive. If nothing is defined all fields are returned.\r\n  - **consistent**: *( `Boolean` optional: default = [tableConfig.consistent] )* do a consitent read  \r\n- **fnCallback**: *( `Function` required )*  \r\nCallback method.  \r\n**Method Arguments**  \r\n  - **err**: Usually `null`. On an error a object with `error` and `msg`\r\n  - **item**: the database item as simple object. If not found `null`\r\n\r\n**Example**\r\n\r\n```coffee\r\ntblTodos.get 'myTodoId', ( err, todo )->\r\n\tif err\r\n\t\tconsole.error( \"get ERROR\", err )\r\n\telse\r\n\t\tconsole.log( todo )\r\n```\r\n\r\n```coffee\r\ntblRangeTodos.get [ 'myHash', 'myRange' ], ( err, todo )->\r\n\tif err\r\n\t\tconsole.error( \"get ERROR\", err )\r\n\telse\r\n\t\tconsole.log( todo )\r\n```\r\n\r\n## Get many items (MGET)\r\n\r\nGet an many existing elements by id/hash in one request\r\n\r\n**`Table.mget( [ id1, id2, .. ], options, fnCallback )` Arguments** : \r\n\r\n- **ids**: *( `Array` required )*  \r\nAn array of id of an elements. If the used table is a range table you have to use an array of arrays `[hash,range]` as combined id. Otherwise you will get an error. \r\n- **options**: *( `Object` optional )*  \r\n  - **fields**: *( `Array` )* An array of fields to receive. If nothing is defined all fields are returned.\r\n- **fnCallback**: *( `Function` required )*  \r\nCallback method.  \r\n**Method Arguments**  \r\n  - **err**: Usually `null`. On an error a object with `error` and `msg`\r\n  - **items**: the database items as a array of simple objects. Only existing items will be received. \r\n\r\n**Example**\r\n\r\n```coffee\r\ntblTodos.mget [ 'myTodoIdA', 'myTodoIdB' ], ( err, todos )->\r\n\tif err\r\n\t\tconsole.error( \"get ERROR\", err )\r\n\telse\r\n\t\tconsole.log( todos )\r\n```\r\n\r\n```coffee\r\ntblRangeTodos.mget [ [ 'myHash', 1 ], [ 'myHash', 2 ] ], ( err, todos )->\r\n\tif err\r\n\t\tconsole.error( \"get ERROR\", err )\r\n\telse\r\n\t\tconsole.log( todos )\r\n```\r\n\r\n## Update an item (UPDATE)\r\n\r\nupdate an existing item.  \r\nTo remove a attribute you have to set the value to `null`\r\n\r\n**`Table.set( id, data, options, fnCallback )` Arguments** : \r\n\r\n- **id**: *( `String|Number|Array` required )*  \r\nThe id of an element. If the used table is a range table you have to use an array `[hash,range]` as combined id. Otherwise you will get an error. \r\n- **data**: *( `Object` required )*  \r\nThe data to update. You can redefine the range key. If you pass the hash key it will be ignored\r\n- **options**: *( `Object` optional )*  \r\nFor update you can define some options.\r\n  - **fields**: *( `Array` )* An array of fields to receive\r\n  - **conditionals** *( `Object` )* A query object to define a conditional. Only `{\"==\": value}`, `{\"==\": null}`, and `{\"!=\": null}` are allowed. How to build? … have a look at [Jed's Predicates ](https://github.com/jed/dynamo/wiki/High-level-API#wiki-predicates)\r\n- **fnCallback**: *( `Function` required )*  \r\nCallback method.  \r\n**Method Arguments**  \r\n  - **err**: Usually `null`. On an error a object with `error` and `msg`\r\n  - **item**: the database item as simple object. If not found `null`\r\n\r\n**Example**\r\n\r\n```coffee\r\ndata = \r\n\ttitle: \"My First Update\"\r\n\tdone: 1\r\n\t\r\ntblTodos.set 'myTodoId', data, ( err, todo )->\r\n\tif err\r\n\t\tconsole.error( \"update ERROR\", err )\r\n\telse\r\n\t\t# note. the key 'aditionalData' will be gone\r\n\t\tconsole.log( todo )\r\n```\r\n\r\n## Delete an item (DELETE)\r\n\r\ndelete an item by id/hash\r\n\r\n**`Table.del( id, fnCallback )` Arguments** : \r\n\r\n- **id**: *( `String|Number|Array` required )*  \r\nThe id of an element. If the used table is a range table you have to use an array `[hash,range]` as combined id. Otherwise you will get an error. \r\n- **fnCallback**: *( `Function` required )*  \r\nCallback method.  \r\n**Method Arguments**  \r\n  - **err**: Usually `null`. On an error a object with `error` and `msg`\r\n\r\n**Example**\r\n\r\n```coffee\r\ntblTodos.del 'myTodoId', ( err )->\r\n\tif err\r\n\t\tconsole.error( \"delete ERROR\", err )\r\n\telse\r\n\t\tconsole.log( \"delete done\" )\r\n```\r\n\r\n## Query a table (FIND)\r\n\r\nrun a query on a table. The module automatically trys to do a `Dynamo.db scan` or `Dynamo query`.\r\n\r\n**`Table.find( query, startAt, options, fnCallback )` Arguments** : \r\n\r\n- **query**: *( `Object` : default = `{}` all )*  \r\nA query object. How to build … have a look at [Jed's Predicates ](https://github.com/jed/dynamo/wiki/High-level-API#wiki-predicates)\r\n- **startAt**: *( `String|Number|Array` optional )*  \r\nTo realize a paging you can define a `startAt`. Usually the last item of a list. If you define `startAt` with the last item of the previous find you get the next collection of items without the given `startAt` item.  \r\nIf the used table is a range table you have to use an array `[hash,range]` as combined `startAt`. Otherwise you will get an error. \r\n- **options**: *( `Object` optional )*  \r\n  - **fields**: *( `Array` )* An array of fields to receive\r\n  - **limit**: *( `Number` )* Define the max. items to return\r\n  - **forward**: *( `Boolean` default = true  )* define the direction `acs` or `desc` for range querys. \r\n  - **consistent**: *( `Boolean` optional: default = [tableConfig.consistent] )* do a consitent read.  \r\n  **Note! This is only availible for real query's through range-tables. This means if you query by hash and range ( e.g. Advanced Examples )**\r\n- **fnCallback**: *( `Function` required )*  \r\nCallback method.  \r\n**Method Arguments**  \r\n  - **err**: Usually `null`. On an error a object with `error` and `msg`\r\n  - **items**: an array of objects found\r\n\t\r\n\r\n**Example**\r\n\r\n```coffee\r\ntblTodos.find {}, ( err, items )->\r\n\tif err\r\n\t\tconsole.error( \"delete ERROR\", err )\r\n\telse\r\n\t\tconsole.log( \"all existend items\", items )\r\n```\r\n**Advanced Examples**\r\n\r\n```coffee\r\n# create a query to read all todos from last hour\r\n_query = \r\n\tid: { \"!=\": null }\r\n\t_t: { \"<\": ( Date.now() - ( 1000 * 60 * 60 ) ) }\r\n\r\ntblTodos.find , ( err, items )->\r\n\tif err\r\n\t\tconsole.error( \"delete ERROR\", err )\r\n\telse\r\n\t\tconsole.log( \"found items\", items )\r\n```\r\n\r\n```coffee\r\n# read 4 todos from last hour beginning starting with a known id\r\n_query = \r\n\tid: { \"!=\": null }\r\n\t_t: { \"<\": ( Date.now() - ( 1000 * 60 * 60 ) ) }\r\n\r\n_startAt = \"myid_todoItem12\"\r\n\r\n_options = { \"limit\": 4, \"fields\": [ \"id\", \"_t\", \"title\" ] }\r\n\r\ntblTodos.find _query, _startAt, _options, ( err, items )->\r\n\tif err\r\n\t\tconsole.error( \"delete ERROR\", err )\r\n\telse\r\n\t\tconsole.log( \"4 found items\", items )\r\n```\r\n\r\n\r\n## Working with sets\r\n\r\nDynamo has the ability to work with sets. That means you can save a Set of Strings as an Array.  \r\nDuring an update you have the ability to add or remove a single value out of the set. Or you can reset the whole set.  \r\n\r\nBut you can only perform one action per key and you obnly can use the functionalty if defined through the table-definition ( `type:\"array\"` ).\r\n\r\nExisting values will be ignored.\r\n\r\nThe following key variants are availible:\r\n\r\n- `\"key\":[ \"a\", \"b\", \"c\" ]'`: Resets the whole value of the key\r\n- `\"key\":{ \"$add\": [ \"d\", \"e\" ] }`: Add some values to the set\r\n- `\"key\":{ \"$rem\": [ \"a\", \"b\" ] }`: remove some values\r\n- `\"key\":{ \"$reset\": [ \"x\", \"y\" ] }`: reset the whole value. Same as `\"key\":[ \"x\", \"y\" ]'`\r\n- `\"key\":{ \"$add\": \"d\"}`: Add a single value to the set\r\n- `\"key\":{ \"$rem\": \"a\" }`: remove a single value\r\n- `\"key\":{ \"$reset\": \"y\" }`: reset the whole set to a single value. Same as `\"key\":[ \"y\" ]'`\r\n\r\n**Examples**\r\n\r\n```coffee\r\n# Source \"key: [ \"a\", \"b\", \"c\" ]\"\r\n\r\ndata = \r\n    key: [ \"x\", \"y\", \"z\" ]\r\n\r\ntblSets.set 'mySetsId', data, ( err, setData )->\r\n    # Result \"key: [ \"x\", \"y\", \"z\" ]\"\r\n    console.log( setData )\r\n```\r\n```\r\n# Source \"key: [ \"a\", \"b\", \"c\" ]\"\r\n\r\ndata = \r\n    key: { \"$add\": [ \"a\", \"d\", \"e\" ] }\r\n\r\ntblSets.set 'mySetsId', data, ( err, setData )->\r\n    # Result \"key: [ \"a\", \"b\", \"c\", \"d\", \"e\" ]\"\r\n    console.log( setData )\r\n```\r\n```\r\n# Source \"key: [ \"a\", \"b\", \"c\" ]\"\r\n\r\ndata = \r\n    key: { \"$rem\": [ \"a\", \"b\", \"x\" ] }\r\n\r\ntblSets.set 'mySetsId', data, ( err, setData )->\r\n    # Result \"key: [ \"c\" ]\"\r\n    console.log( setData )\r\n```\r\n```\r\n# Source \"key: [ \"a\", \"b\", \"c\" ]\"\r\n\r\ndata = \r\n    key: { \"$reset\": [ \"x\", \"y\", \"z\" ] }\r\n\r\ntblSets.set 'mySetsId', data, ( err, setData )->\r\n    # Result \"key: [ \"x\", \"y\", \"z\" ]\"\r\n    console.log( setData )\r\n```\r\n\r\n#Events\r\n\r\nTo provide a API to react on different events you can listen to a bunch of events.\r\n\r\n##Manager Events\r\n\r\n- `new-table`: Table object initialized and ready to use. This means only the client model is ready. Eventually you have to create the table first.  \r\n**Event Arguments**  \r\n\t- **name**: the name og the table, like you would use with `Manager.get()\r\n\t- **Table**: the `Table` object\r\n- `table-generated`: Fired after all a new tables has been generated.\r\n**Event Arguments**  \r\n\t- **Meta**: the tables meta-data\r\n- `all-tables-generated`: Fired after all tables are generated.  \r\n\r\n\r\n##Table Events\r\n\r\n- `create-status`: fired on table create.  \r\n**Event Arguments**  \r\n\t- **status**: describes the state of table creation. Possible values are: `already-active`, `waiting`, `active`\r\n- `get`: fired after a table.get.  \r\n**Event Arguments**  \r\n\t- **item**: the item\r\n- `get-empty`: fired after a table.get with an empty result.  \r\n- `mget`: fired after a table.mget.  \r\n**Event Arguments**  \r\n\t- **items**: the items\r\n- `mget-empty`: fired after a table.mget with no results.  \r\n- `create`: fired after a item has been created.  \r\n**Event Arguments**  \r\n\t- **item**: the created item\r\n- `update`: fired after a item has been updated.  \r\n**Event Arguments**  \r\n\t- **item_new**: the item after the update\r\n- `delete`: fired after a item has been deleted.  \r\n**Event Arguments**  \r\n\t- **item_old**: the item before the delete\r\n\t\r\n## Changelogs\r\n\r\n### 0.3.5\r\n\r\n- fixed #5: fixed bug for set empty array on create\r\n- fixed #9: fixed bug for null on fliedtype `number\r\n\r\n### 0.3.4\r\n\r\n- fixed #7: bug fix set a attribute to `null` will lead to a removal. For a string attribute a set to an empty string will also lead to a attribute removal\r\n\r\n### 0.3.3\r\n\r\n- bug fix set handling by passing empty arrays\r\n- feature #6: added `defaultfields` option to table-config.\r\n\r\n### 0.3.2\r\n\r\n- added implicit set detection for `update` by testing for a object with one of the keys `$add`, `$rem` and `$reset` \r\n\r\n### 0.3.1\r\n\r\n- bugfix `option.forward` on `find.()`\r\n \r\n### 0.3.0\r\n- changed update behavior. Now there is not get before set.\r\n- Event `update`, no longer with new and old value. Just the new value. This is a victim to the removal of get before set.\r\n- added option `conditionals` to update. So you can define conditions to your update\r\n- removed option `removeMissing`. Now you have to set a attribute to `null` to remove it.\r\n- added `forward` option to `.find()` to define the direction of a range query\r\n\r\n## Todos\r\n\r\n- handle `throughput exceed`with a retry\r\n- better check of the given config-data\r\n- check for node.js 0.8.0 \r\n\r\n### Work in progress\r\n\r\n`simple-dynamo` is work in progress. Your ideas, suggestions etc. are very welcome.\r\n\r\n## License \r\n\r\n(The MIT License)\r\n\r\nCopyright (c) 2010 TCS &lt;dev (at) tcs.de&gt;\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n'Software'), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","tagline":"simple-dynamo is a abstraction layer to simplify Jed Schmidt's dynamo Node.js driver."}